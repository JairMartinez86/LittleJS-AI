<!DOCTYPE html><head>
 <title>LittleJS AI Starter Project</title>
 <meta charset=utf-8>
 </head><body style="background:#000">
 <script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.11/dist/littlejs.js"></script>
 <script>
 'use strict';
 
 // engine settings, do not remove
 debugWatermark = false; // Hide debug watermark in corner
 showEngineVersion = false; // Hide engine version console display
 
 // AI can use this class to make sound effects
 class SoundGenerator extends Sound 
 {
     constructor(params = {})
     {
         const {
             volume = 1,        // Volume scale (percent)
             randomness = .05,  // How much to randomize frequency (percent Hz)
             frequency = 220,   // Frequency of sound (Hz)
             attack = 0,        // Attack time, how fast sound starts (seconds)
             release = .1,      // Release time, how fast sound fades out (seconds)
             shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
             slide = 0,         // How much to slide frequency (kHz/s)
             pitchJump = 0,     // Frequency of pitch jump (Hz)
             pitchJumpTime = 0, // Time of pitch jump (seconds)
             repeatTime = 0,    // Resets some parameters periodically (seconds)
             noise = 0,         // How much random noise to add (percent)
             bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
             delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
         } = params;
         
         super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 // 2048 (LittleJS) — single-file, no textures
 
 const GRID = 4;
 const CELL_SIZE = 1;
 const GAP = .12;
 
 let grid;
 let popGrid;
 let score = 0;
 let best = 0;
 let gameOver = false;
 let won = false;
 let continueAfterWin = false;
 
 let swipeStartScreen;
 let swipeArmed = false;
 
 // sounds
 let sMove, sMerge, sSpawn, sLose, sWin;
 
 function gameInit()
 {
     // called once after the engine starts up
     setCanvasFixedSize(vec2(720, 900));
     setCanvasClearColor(hsl(0,0,.08));
     setEnablePhysicsSolver(false);
     setShowSplashScreen(false);
     setFontDefault('arial');
 
     best = +localStorage.getItem('ljs2048_best') || 0;
 
     sMove  = new SoundGenerator({frequency:260, release:.06, volume:.7, randomness:.02});
     sMerge = new SoundGenerator({frequency:190, pitchJump:320, pitchJumpTime:.02, release:.14, volume:.9, randomness:.02});
     sSpawn = new SoundGenerator({frequency:520, release:.05, volume:.35, randomness:.05});
     sLose  = new SoundGenerator({frequency:120, slide:-.15, release:.35, volume:.9, randomness:.02});
     sWin   = new SoundGenerator({frequency:620, pitchJump:220, pitchJumpTime:.05, release:.25, volume:1, randomness:.01});
 
     newGame();
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function newGame()
 {
     score = 0;
     gameOver = false;
     won = false;
     continueAfterWin = false;
 
     grid = [];
     popGrid = [];
     for (let y=0; y<GRID; ++y)
     {
         grid[y] = [];
         popGrid[y] = [];
         for (let x=0; x<GRID; ++x)
         {
             grid[y][x] = 0;
             popGrid[y][x] = 0;
         }
     }
 
     addRandomTile();
     addRandomTile();
 }
 
 function boardWorldSize()
 {
     return GRID*CELL_SIZE + (GRID+1)*GAP;
 }
 
 function cellCenterWorld(x, y)
 {
     const s = boardWorldSize();
     const o = -s/2;
     return vec2(
         o + GAP + CELL_SIZE/2 + x*(CELL_SIZE+GAP),
         o + GAP + CELL_SIZE/2 + (GRID-1-y)*(CELL_SIZE+GAP) // y=0 is top
     );
 }
 
 function empties()
 {
     const e = [];
     for (let y=0; y<GRID; ++y)
         for (let x=0; x<GRID; ++x)
             if (!grid[y][x]) e.push([x,y]);
     return e;
 }
 
 function addRandomTile()
 {
     const e = empties();
     if (!e.length) return false;
     const [x,y] = e[(Math.random()*e.length)|0];
     const v = Math.random() < .9 ? 2 : 4;
     grid[y][x] = v;
     popGrid[y][x] = .14;
     sSpawn.play();
     return true;
 }
 
 function slideLine(line)
 {
     // standard 2048 rules: compress, merge once per pair, compress
     const src = line.filter(v=>v);
     const out = [];
     let moved = false;
     let mergedAny = false;
 
     for (let i=0; i<src.length; ++i)
     {
         let v = src[i];
         if (i+1 < src.length && src[i+1] === v)
         {
             v *= 2;
             i++;
             score += v;
             mergedAny = true;
             moved = true;
         }
         out.push(v);
     }
     while (out.length < GRID) out.push(0);
 
     // did anything move?
     for (let i=0; i<GRID; ++i)
         if (out[i] !== line[i]) { moved = true; break; }
 
     return {out, moved, mergedAny};
 }
 
 function canMove()
 {
     for (let y=0; y<GRID; ++y)
         for (let x=0; x<GRID; ++x)
         {
             const v = grid[y][x];
             if (!v) return true;
             if (x+1<GRID && grid[y][x+1] === v) return true;
             if (y+1<GRID && grid[y+1][x] === v) return true;
         }
     return false;
 }
 
 // dir: 'L','R','U','D'
 function applyMove(dir)
 {
     if (gameOver) return;
     if (won && !continueAfterWin) return;
 
     let anyMoved = false;
     let anyMerged = false;
 
     const markPop = (x,y)=> popGrid[y][x] = max(popGrid[y][x], .16);
 
     if (dir === 'L' || dir === 'R')
     {
         for (let y=0; y<GRID; ++y)
         {
             const row = grid[y].slice();
             const line = dir==='L' ? row : row.slice().reverse();
             const {out, moved, mergedAny} = slideLine(line);
             const newLine = dir==='L' ? out : out.slice().reverse();
             grid[y] = newLine;
             if (moved) anyMoved = true;
             if (mergedAny)
             {
                 anyMerged = true;
                 // pop merged tiles (approx: any non-zero that changed)
                 for (let x=0; x<GRID; ++x)
                     if (newLine[x] && newLine[x] !== row[x]) markPop(x,y);
             }
         }
     }
     else
     {
         for (let x=0; x<GRID; ++x)
         {
             const col = [];
             for (let y=0; y<GRID; ++y) col.push(grid[y][x]);
             const line = dir==='U' ? col : col.slice().reverse();
             const {out, moved, mergedAny} = slideLine(line);
             const newLine = dir==='U' ? out : out.slice().reverse();
             for (let y=0; y<GRID; ++y)
             {
                 const oldV = grid[y][x];
                 const newV = newLine[y];
                 grid[y][x] = newV;
                 if (mergedAny && newV && newV !== oldV) markPop(x,y);
             }
             if (moved) anyMoved = true;
             if (mergedAny) anyMerged = true;
         }
     }
 
     if (!anyMoved)
         return;
 
     // commit
     if (anyMerged) sMerge.play();
     else sMove.play();
 
     best = max(best, score);
     localStorage.setItem('ljs2048_best', best);
 
     // win check
     if (!won)
     {
         outer: for (let y=0; y<GRID; ++y)
             for (let x=0; x<GRID; ++x)
                 if (grid[y][x] >= 2048) { won = true; sWin.play(); break outer; }
     }
 
     addRandomTile();
 
     if (!canMove())
     {
         gameOver = true;
         sLose.play();
     }
 }
 
 function readMoveInput()
 {
     // keyboard
     if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA')) return 'L';
     if (keyWasPressed('ArrowRight')|| keyWasPressed('KeyD')) return 'R';
     if (keyWasPressed('ArrowUp')   || keyWasPressed('KeyW')) return 'U';
     if (keyWasPressed('ArrowDown') || keyWasPressed('KeyS')) return 'D';
 
     // swipe (touch maps to mouse)
     if (mouseWasPressed(0))
     {
         swipeStartScreen = mousePosScreen.copy();
         swipeArmed = true;
     }
     if (swipeArmed && mouseWasReleased(0))
     {
         swipeArmed = false;
         const d = mousePosScreen.subtract(swipeStartScreen);
         const ax = abs(d.x), ay = abs(d.y);
         const minSwipe = 40;
         if (max(ax, ay) < minSwipe) return;
         if (ax > ay) return d.x < 0 ? 'L' : 'R';
         return d.y < 0 ? 'U' : 'D';
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameUpdate()
 {
     // called every frame at 60 frames per second
     // handle input and update the game state
 
     // decay pop timers
     for (let y=0; y<GRID; ++y)
         for (let x=0; x<GRID; ++x)
             popGrid[y][x] = max(0, popGrid[y][x] - timeDelta);
 
     if (keyWasPressed('KeyR'))
         newGame();
 
     if (won && !continueAfterWin && keyWasPressed('KeyC'))
         continueAfterWin = true;
 
     const dir = readMoveInput();
     if (dir)
         applyMove(dir);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameUpdatePost()
 {
     // called after physics and objects are updated
     // setup camera and prepare for render
 
     cameraPos = vec2(0,0);
     const s = boardWorldSize();
     const margin = 1.1;
     const viewPixels = min(mainCanvasSize.x, mainCanvasSize.y*0.78);
     cameraScale = viewPixels / (s + margin*2);
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function tileFillColor(v)
 {
     const p = clamp((log2(v)-1)/11, 0, 1);
     const hue = .12 - .10*p;          // golden -> red
     const sat = .55 + .25*p;
     const lit = .80 - .38*p;
     return hsl(hue, sat, lit);
 }
 
 function tileTextColor(v)
 {
     return v <= 4 ? hsl(0,0,.15) : hsl(0,0,.98);
 }
 
 function gameRender()
 {
     // called before objects are rendered
     // draw any background effects that appear behind objects
 
     // big backdrop in world space so resizing is safe
     drawRect(cameraPos, vec2(200), hsl(0,0,.09));
 
     const boardSize = boardWorldSize();
     drawRect(vec2(0,0), vec2(boardSize), hsl(0,0,.18));
 
     // cells + tiles
     for (let y=0; y<GRID; ++y)
     for (let x=0; x<GRID; ++x)
     {
         const c = cellCenterWorld(x,y);
         // empty slot
         drawRect(c, vec2(CELL_SIZE), hsl(0,0,.25));
 
         const v = grid[y][x];
         if (!v) continue;
 
         const pop = popGrid[y][x];
         const popT = pop ? pop/.16 : 0;
         const scale = 1 + .10*popT;
         const size = vec2(CELL_SIZE*.92*scale);
 
         drawRect(c, size, tileFillColor(v));
 
         const digits = (''+v).length;
         const textSize = clamp(.52 - .07*(digits-1), .24, .52);
         drawText(
             ''+v,
             c.add(vec2(0, -textSize*.06)),
             textSize,
             tileTextColor(v),
             .08,
             hsl(0,0,.05)
         );
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 function gameRenderPost()
 {
     // UI
     const topY = 54;
     drawTextScreen('2048', vec2(86, topY), 64, hsl(.12,.7,.9), 6, hsl(0,0,0));
 
     drawTextScreen(`Score: ${score}`, vec2(mainCanvasSize.x/2, topY), 34, hsl(0,0,1), 4, hsl(0,0,0));
     drawTextScreen(`Best: ${best}`, vec2(mainCanvasSize.x-110, topY), 28, hsl(0,0,.9), 4, hsl(0,0,0));
 
     drawTextScreen('Arrows/WASD or swipe • R = restart', vec2(mainCanvasSize.x/2, mainCanvasSize.y-22), 20, hsl(0,0,.8), 3, hsl(0,0,0));
 
     if (won && !continueAfterWin)
     {
         drawRect(vec2(mainCanvasSize.x/2, mainCanvasSize.y/2), mainCanvasSize, hsl(0,0,0,.55), 0, false, true);
         drawTextScreen('You made 2048!', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2-30), 56, hsl(.25,.7,.9), 6, hsl(0,0,0));
         drawTextScreen('Press C to keep going', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2+28), 28, hsl(0,0,1), 4, hsl(0,0,0));
     }
 
     if (gameOver)
     {
         drawRect(vec2(mainCanvasSize.x/2, mainCanvasSize.y/2), mainCanvasSize, hsl(0,0,0,.65), 0, false, true);
         drawTextScreen('Game Over', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2-18), 64, hsl(0,0,1), 6, hsl(0,0,0));
         drawTextScreen('Press R to restart', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2+36), 28, hsl(0,0,.9), 4, hsl(0,0,0));
     }
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 // Startup LittleJS Engine
 engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);
 
 </script>
