<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/littlejs.js"></script>
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/box2d.wasm.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display
paused = false; // Start unpaused

// engine settings, customize if necessary
gravity = vec2(0, 0);
objectDefaultDamping = .01;
objectDefaultAngleDamping = .01;
cameraScale = 28;
canvasClearColor = hsl(0,0,.08); // set immediately so we don't flash white while loading
cameraPos = vec2();

///////////////////////////////////////////////////////////////////////////////
// Pinball (Box2D) - tiny prototype
//
// Fix for "Assert failed!": LittleJS Box2D helpers use `addCircle(diameter, ... isSensor)`
// where the last parameter MUST be a boolean. The earlier code accidentally passed a
// number as isSensor (e.g. 0.4), which triggers LittleJS ASSERT.
//
// Note: We use LittleJS's built-in Sound class for SFX so we don't depend on any
// optional helper like SoundGenerator.

const FIELD_W = 16;
const FIELD_H = 28;
const FIELD_BOTTOM = -FIELD_H/2;
const FIELD_TOP    =  FIELD_H/2;

let table;                 // Box2dStaticObject holding walls
let ball;                  // Box2dObject
let score = 0;
let ballsLeft = 3;

let leftFlipper, rightFlipper;
let leftJoint, rightJoint;

let launchCharge = 0;
let canLaunch = false;

// simple sfx (LittleJS Sound)
let sfxBumper, sfxFlip, sfxDrain;

let ready = false;
let initError = '';

class Bumper extends Box2dStaticObject
{
    // radius is in world units; addCircle expects diameter
    constructor(pos, radius=1.1)
    {
        super(pos);
        this.color = hsl(.12, .8, .55);
        this.lineColor = hsl(0,0,0);
        this.lineWidth = .15;

        const diameter = radius * 2;
        // addCircle(diameter, offset, density, friction, restitution, isSensor)
        // For static objects, density is ignored, but we keep it 0.
        this.addCircle(diameter, vec2(), 0, .2, .95, false);
    }

    beginContact(other)
    {
        if (other != ball) return;

        score += 100;

        // kick the ball away from the bumper center
        const dir = ball.pos.subtract(this.pos);
        const n = dir.length() ? dir.normalize() : vec2(0,1);
        ball.applyAcceleration(n.scale(25)); // impulse-ish

        sfxBumper && sfxBumper.play(ball.pos);
    }
}

class Flipper extends Box2dObject
{
    constructor(pos, angle, isRight=false)
    {
        super(pos, vec2(), 0, angle, hsl(isRight?.55:.05, .7, .55));
        this.lineColor = hsl(0,0,0);
        this.lineWidth = .12;

        // addBox(size, offset, angle, density, friction, restitution, isSensor)
        this.addBox(vec2(4.2, .75), vec2(), 0, 3, .4, .1, false);
        this.setAngularDamping(8);
        this.setDamping(1);
        this.setBullet(true);
    }
}

function makeWalls()
{
    table = new Box2dStaticObject(vec2());
    table.color = hsl(0,0,.15);
    table.lineColor = hsl(0,0,0);
    table.lineWidth = .15;

    // outer walls
    table.addBox(vec2(1, FIELD_H+2), vec2(-FIELD_W/2 - .5, 0), 0, 0, .2, .2, false);
    table.addBox(vec2(1, FIELD_H+2), vec2( FIELD_W/2 + .5, 0), 0, 0, .2, .2, false);
    table.addBox(vec2(FIELD_W+2, 1), vec2(0, FIELD_TOP + .5), 0, 0, .2, .2, false);

    // shooter lane wall (right)
    table.addBox(vec2(1, FIELD_H*0.65), vec2(5.8, FIELD_BOTTOM + FIELD_H*0.325), 0, 0, .2, .2, false);

    // bottom sloped guides to flippers
    table.addBox(vec2(6.5, 1), vec2(-4.0, FIELD_BOTTOM + 2.3),  0.30, 0, .2, .2, false);
    table.addBox(vec2(6.5, 1), vec2( 4.0, FIELD_BOTTOM + 2.3), -0.30, 0, .2, .2, false);

    // little posts near drain
    table.addBox(vec2(.6, 1.8), vec2(-1.8, FIELD_BOTTOM + 1.2), 0, 0, .2, .2, false);
    table.addBox(vec2(.6, 1.8), vec2( 1.8, FIELD_BOTTOM + 1.2), 0, 0, .2, .2, false);

    // top angled nudges
    table.addBox(vec2(6, 1), vec2(-4.5, FIELD_TOP-2.5), -0.35, 0, .2, .2, false);
    table.addBox(vec2(6, 1), vec2( 4.5, FIELD_TOP-2.5),  0.35, 0, .2, .2, false);
}

function makeFlippers()
{
    // left flipper pivots near left wall, points toward center
    const leftPivot  = vec2(-5.4, FIELD_BOTTOM + 2.2);
    const leftCenter = leftPivot.add(vec2(2.1, .15));
    leftFlipper = new Flipper(leftCenter, 0.20, false);

    leftJoint = new Box2dRevoluteJoint(table, leftFlipper, leftPivot);
    leftJoint.enableLimit(true);
    leftJoint.setLimits(-0.95, 0.25);
    leftJoint.enableMotor(true);
    leftJoint.setMaxMotorTorque(2200);

    // right flipper pivots near right wall, points toward center (angle ~ PI)
    const rightPivot  = vec2(5.4, FIELD_BOTTOM + 2.2);
    const rightCenter = rightPivot.add(vec2(-2.1, .15));
    rightFlipper = new Flipper(rightCenter, PI-0.20, true);

    rightJoint = new Box2dRevoluteJoint(table, rightFlipper, rightPivot);
    rightJoint.enableLimit(true);
    rightJoint.setLimits(PI-0.25, PI+0.95); // down near PI+0.95, up near PI-0.25
    rightJoint.enableMotor(true);
    rightJoint.setMaxMotorTorque(2200);
}

function spawnBall(isNewBall=false)
{
    if (ball) ball.destroy();

    if (isNewBall)
        ballsLeft = max(0, ballsLeft-1);

    // start in shooter lane
    const startPos = vec2(6.9, FIELD_BOTTOM + 1.6);
    ball = new Box2dObject(startPos, vec2(), 0, 0, WHITE);
    ball.lineColor = hsl(0,0,0);
    ball.lineWidth = .12;

    // addCircle expects DIAMETER (not radius) and the last param isSensor must be boolean
    ball.addCircle(1.1, vec2(), 1.0, .05, .35, false);

    ball.setBullet(true);
    ball.setAngularDamping(.2);
    ball.setDamping(.05);
    ball.setGravityScale(1);
}

function ballIsInShooterLane()
{
    return ball && ball.pos.x > 6 && ball.pos.y < FIELD_BOTTOM + 4;
}

function ballIsDrained()
{
    return ball && ball.pos.y < FIELD_BOTTOM - 3;
}

function runSelfTests()
{
    // Basic runtime checks (non-fatal). Return false if something critical is missing.
    const okSound = (typeof Sound == 'function');
    const okBox2d = (typeof box2dInit == 'function');
    const okWrap  = (typeof Box2dObject != 'undefined');
    const okCircleSig = (typeof Box2dObject != 'undefined') && (typeof Box2dObject.prototype.addCircle == 'function');

    console.assert(okSound, 'LittleJS Sound class should exist');
    console.assert(okBox2d, 'Box2D should be loaded (box2d.wasm.js)');
    console.assert(okWrap,  'LittleJS Box2D wrapper classes should exist');
    console.assert(okCircleSig, 'Box2dObject.addCircle should exist');

    return okSound && okBox2d && okWrap && okCircleSig;
}

// Added test cases: validate we never pass a non-boolean isSensor
function assertCircleArgs(isSensor)
{
    console.assert(typeof isSensor == 'boolean', 'isSensor must be boolean');
}

async function gameInit()
{
    // called once after the engine starts up
    // IMPORTANT: Wrap init so any error shows on screen (not just console)
    try
    {
        ready = false;
        initError = '';

        const ok = runSelfTests();
        if (!ok)
            throw new Error('Missing required LittleJS/Box2D pieces (see console asserts).');

        // Our local test cases for argument types
        assertCircleArgs(false);

        // setup box2d first!
        await box2dInit();

        // pinball gravity (down)
        gravity = vec2(0, -85);

        // sounds (zzfx-style params; Sound.play(worldPos) supported)
        // [volume, randomness, frequency, attack, sustain, release, shape, shapeCurve, slide,
        //  deltaSlide, pitchJump, pitchJumpTime, repeatTime, noise, modulation, bitCrush, delay,
        //  sustainVolume, decay, tremolo]
        sfxBumper = new Sound([1.0, .06, 520, 0, .03, .10, 2, 0, 0, 0, 0, 0, 0, .02, 0, 0, 0, 1, 0, 0]);
        sfxFlip   = new Sound([1.2, .03, 260, 0, .02, .08, 1, 0, 0, 0, 0, 0, 0, .01, 0, 0, 0, 1, 0, 0]);
        sfxDrain  = new Sound([0.9, .10, 140, 0, .06, .28, 0, 0, -0.2, 0, 0, 0, 0, .06, 0, 0, 0, 1, 0, 0]);

        makeWalls();
        makeFlippers();

        // bumpers (triangle-ish layout)
        new Bumper(vec2(-3.5, 4.0), 1.15);
        new Bumper(vec2( 0.0, 6.0), 1.20);
        new Bumper(vec2( 3.5, 4.0), 1.15);

        // a couple small posts (smaller bumpers)
        const postA = new Bumper(vec2(-5.8, -1.0), .7); postA.color = hsl(.55,.6,.5);
        const postB = new Bumper(vec2( 5.0, -1.5), .7); postB.color = hsl(.55,.6,.5);

        spawnBall(false);

        // extra sanity checks
        console.assert(table, 'table should exist');
        console.assert(ball, 'ball should exist');

        ready = true;
    }
    catch(e)
    {
        initError = (e && (e.stack || e.message)) ? (e.stack || e.message) : 'Unknown init error';
        console.error(e);
        ready = false;
    }
}

function gameUpdate()
{
    if (!ready) return;

    // flipper input
    const leftDown  = keyIsDown('ArrowLeft') || keyIsDown('KeyA');
    const rightDown = keyIsDown('ArrowRight') || keyIsDown('KeyD');

    // left joint angles go toward min when pressed (negative speed = CCW)
    leftJoint && leftJoint.setMotorSpeed(leftDown ? -35 : 25);
    rightJoint && rightJoint.setMotorSpeed(rightDown ? -35 : 25);

    // sfx on press
    if (keyWasPressed('ArrowLeft') || keyWasPressed('KeyA') ||
        keyWasPressed('ArrowRight') || keyWasPressed('KeyD'))
        sfxFlip && sfxFlip.play();

    // launcher charge (Space)
    if (ballIsInShooterLane())
    {
        canLaunch = true;

        if (keyIsDown('Space'))
            launchCharge = min(1, launchCharge + timeDelta*1.2);
        else if (launchCharge > 0 && keyWasReleased('Space'))
        {
            // impulse upwards + slight left to enter field
            const power = lerp(18, 55, launchCharge);
            ball.applyAcceleration(vec2(-5, power));
            launchCharge = 0;
            canLaunch = false;
        }
    }
    else
    {
        launchCharge = 0;
        canLaunch = false;
    }

    // drain check
    if (ballIsDrained())
    {
        sfxDrain && sfxDrain.play();
        if (ballsLeft > 0)
            spawnBall(true);
        else
        {
            // game over -> restart
            ballsLeft = 3;
            score = 0;
            spawnBall(false);
        }
    }

    // gentle nudge (optional)
    if (keyWasPressed('KeyQ')) { ball && ball.applyAcceleration(vec2(-8, 0)); }
    if (keyWasPressed('KeyE')) { ball && ball.applyAcceleration(vec2( 8, 0)); }
}

function gameUpdatePost()
{
    // camera follows a bit upward to show action
    const target = vec2(0, 1.0);
    cameraPos = cameraPos.lerp(target, .08);
    cameraScale = lerp(cameraScale, 28, .05);
}

function gameRender()
{
    // Always draw something so we never show a blank/white screen
    drawRect(vec2(0,0), vec2(FIELD_W+1.2, FIELD_H+1.2), hsl(0,0,.12));
    drawRect(vec2(0,0), vec2(FIELD_W, FIELD_H), hsl(0,0,.06));

    // If not ready, also draw a simple "loading" indicator in-world
    if (!ready)
        drawText('Loading Box2D...', vec2(0,0), 1.2, WHITE, 0.1, hsl(0,0,0));
}

function gameRenderPost()
{
    if (!ready)
    {
        // Big on-screen message if init failed or still loading
        const msg = initError ? 'Init Error (open console)' : 'Loading...';
        drawTextScreen(msg, vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 - 30), 42, WHITE, 6, hsl(0,0,0));
        if (initError)
            drawTextScreen('If you can, paste the console error here.', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2 + 20), 24, WHITE, 4, hsl(0,0,0));
        return;
    }

    // HUD
    const y = 40;
    drawTextScreen(`SCORE ${score}`, vec2(140, y), 36, WHITE, 4, hsl(0,0,0));
    drawTextScreen(`BALLS ${ballsLeft}`, vec2(140, y+40), 28, WHITE, 4, hsl(0,0,0));

    // launcher UI
    if (canLaunch)
    {
        const w = 220, h = 16;
        const x = mainCanvasSize.x - w/2 - 30;
        const y2 = mainCanvasSize.y - 50;
        drawRectScreen(vec2(x,y2), vec2(w,h), hsl(0,0,.2));
        drawRectScreen(vec2(x - (w*(1-launchCharge))/2, y2), vec2(w*launchCharge,h), hsl(.12,.8,.55));
        drawTextScreen(`HOLD SPACE`, vec2(x, y2-26), 22, WHITE, 3, hsl(0,0,0));
    }

    // controls hint
    drawTextScreen(`←/A and →/D = flippers   Space = launch   Q/E = nudge`,
        vec2(mainCanvasSize.x/2, mainCanvasSize.y-22), 22, WHITE, 3, hsl(0,0,0));
}

engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);
</script>
