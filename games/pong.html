<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>LittleJS Pong</title>
  <style>
    html, body { margin:0; padding:0; background:#000; overflow:hidden; }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.11/dist/littlejs.min.js"></script>
  <script>
  'use strict';

  // AI can use this class to generate sounds (from the LittleJS starter template)
  class SoundGenerator extends Sound
  {
      constructor(params = {})
      {
          const {
              volume = 1,        // Volume scale (percent)
              randomness = .05,  // How much to randomize frequency (percent Hz)
              frequency = 220,   // Frequency of sound (Hz)
              attack = 0,        // Attack time, how fast sound starts (seconds)
              release = .1,      // Release time, how fast sound fades out (seconds)
              shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
              slide = 0,         // How much to slide frequency (kHz/s)
              pitchJump = 0,     // Frequency of pitch jump (Hz)
              pitchJumpTime = 0, // Time of pitch jump (seconds)
              repeatTime = 0,    // Resets some parameters periodically (seconds)
              noise = 0,         // How much random noise to add (percent)
              bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
              delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
          } = params;

          super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
      }
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////
  // Pong State

  const fieldSize = vec2(40, 22);          // world units
  const halfField = fieldSize.scale(.5);

  const paddleSize = vec2(1.1, 5.2);
  const ballSize   = vec2(1.0, 1.0);

  const paddleSpeed = 18;
  const aiSpeed     = 15;

  const maxBallSpeed = 30;

  let left = { pos: vec2(-halfField.x + 2.2, 0) };
  let right = { pos: vec2( halfField.x - 2.2, 0) };

  let ball = { pos: vec2(0,0), vel: vec2(0,0) };

  let scoreL = 0;
  let scoreR = 0;

  let waitingForServe = true;
  let gameOver = false;
  let aiRight = false; // press T to toggle

  // Sounds
  let sfxPaddle, sfxWall, sfxScore, sfxServe;

  ///////////////////////////////////////////////////////////////////////////////////////////////
  // Helpers

  const clamp01 = (v)=> clamp(v, 0, 1);

  function aabbOverlap(posA, sizeA, posB, sizeB)
  {
      return Math.abs(posA.x - posB.x) < (sizeA.x + sizeB.x) * .5 &&
             Math.abs(posA.y - posB.y) < (sizeA.y + sizeB.y) * .5;
  }

  function clampPaddleY(p)
  {
      const limit = halfField.y - paddleSize.y/2;
      p.pos.y = clamp(p.pos.y, -limit, limit);
  }

  function resetRound(servingToRight)
  {
      ball.pos = vec2(0, 0);
      ball.vel = vec2(0, 0);
      waitingForServe = true;
      gameOver = false;

      // tiny nudge so it doesn't always serve dead-center
      left.pos.y = 0;
      right.pos.y = 0;

      // store who serves next on the ball object
      ball._serveDir = servingToRight ? 1 : -1;
  }

  function serve()
  {
      if (!waitingForServe || gameOver)
          return;

      // Serve direction: +x goes right, -x goes left
      const dirX = ball._serveDir ?? (randBool() ? 1 : -1);
      const angle = rand(-.25, .25); // slight vertical variance
      const speed = 14;
      ball.vel = vec2(dirX, angle).normalize(speed);
      waitingForServe = false;
      sfxServe?.play(ball.pos);
  }

  function addScore(leftScored)
  {
      if (leftScored) scoreL++;
      else scoreR++;

      sfxScore?.play();

      // win at 10
      if (scoreL >= 10 || scoreR >= 10)
      {
          gameOver = true;
          ball.vel = vec2(0,0);
          waitingForServe = true;
          return;
      }

      // Next serve goes toward the player who just conceded
      resetRound(leftScored ? false : true);
  }

  ///////////////////////////////////////////////////////////////////////////////////////////////
  // LittleJS Callbacks

  function gameInit()
  {
      // fixed canvas for consistent feel
      setCanvasFixedSize(vec2(1280, 720));

      // camera centered; choose scale so field fits nicely
      setCameraPos(vec2(0, 0));
      cameraScale = 32;

      // Sounds (simple, punchy)
      sfxPaddle = new SoundGenerator({ volume:.7, frequency:520, release:.07, shapeCurve:1.8, randomness:.08 });
      sfxWall   = new SoundGenerator({ volume:.55, frequency:880, release:.06, shapeCurve:1.2, randomness:.04 });
      sfxServe  = new SoundGenerator({ volume:.55, frequency:320, release:.12, slide:.35, shapeCurve:1.6, randomness:.06 });
      sfxScore  = new SoundGenerator({ volume:1,  frequency:220, attack:0, release:.35, slide:-1.1, pitchJump:660, pitchJumpTime:.08, shapeCurve:1.3, randomness:.02 });

      resetRound(true);
  }

  function gameUpdate()
  {
      if (keyWasPressed('KeyR'))
      {
          scoreL = scoreR = 0;
          resetRound(true);
      }

      if (keyWasPressed('KeyT'))
          aiRight = !aiRight;

      if (keyWasPressed('Space'))
      {
          if (gameOver)
          {
              scoreL = scoreR = 0;
              resetRound(true);
          }
          serve();
      }

      // Paddle input
      let moveL = 0;
      if (keyIsDown('KeyW')) moveL += 1;
      if (keyIsDown('KeyS')) moveL -= 1;
      left.pos.y += moveL * paddleSpeed * timeDelta;
      clampPaddleY(left);

      if (!aiRight)
      {
          let moveR = 0;
          if (keyIsDown('ArrowUp'))   moveR += 1;
          if (keyIsDown('ArrowDown')) moveR -= 1;
          right.pos.y += moveR * paddleSpeed * timeDelta;
      }
      else
      {
          // simple AI: chase ball when it's moving toward it, otherwise drift to center
          const targetY = (!waitingForServe && ball.vel.x > 0) ? ball.pos.y : 0;
          const delta = clamp(targetY - right.pos.y, -1, 1);
          right.pos.y += delta * aiSpeed * timeDelta;
      }
      clampPaddleY(right);

      // Ball update
      if (waitingForServe || gameOver)
          return;

      ball.pos = ball.pos.add(ball.vel.scale(timeDelta));

      // Wall bounce
      const yLimit = halfField.y - ballSize.y/2;
      if (ball.pos.y > yLimit)
      {
          ball.pos.y = yLimit;
          ball.vel.y = -Math.abs(ball.vel.y);
          sfxWall?.play(ball.pos);
      }
      else if (ball.pos.y < -yLimit)
      {
          ball.pos.y = -yLimit;
          ball.vel.y = Math.abs(ball.vel.y);
          sfxWall?.play(ball.pos);
      }

      // Paddle collisions
      const leftPaddlePos  = left.pos;
      const rightPaddlePos = right.pos;

      // Left paddle
      if (ball.vel.x < 0 && aabbOverlap(ball.pos, ballSize, leftPaddlePos, paddleSize))
      {
          ball.pos.x = leftPaddlePos.x + (paddleSize.x + ballSize.x) * .5;
          ball.vel.x = Math.abs(ball.vel.x);

          const offset = clamp((ball.pos.y - leftPaddlePos.y) / (paddleSize.y * .5), -1, 1);
          ball.vel.y += offset * 8;

          const speed = clamp(ball.vel.length() * 1.04, 14, maxBallSpeed);
          ball.vel = ball.vel.normalize(speed);
          sfxPaddle?.play(ball.pos);
      }

      // Right paddle
      if (ball.vel.x > 0 && aabbOverlap(ball.pos, ballSize, rightPaddlePos, paddleSize))
      {
          ball.pos.x = rightPaddlePos.x - (paddleSize.x + ballSize.x) * .5;
          ball.vel.x = -Math.abs(ball.vel.x);

          const offset = clamp((ball.pos.y - rightPaddlePos.y) / (paddleSize.y * .5), -1, 1);
          ball.vel.y += offset * 8;

          const speed = clamp(ball.vel.length() * 1.04, 14, maxBallSpeed);
          ball.vel = ball.vel.normalize(speed);
          sfxPaddle?.play(ball.pos);
      }

      // Scoring
      if (ball.pos.x < -halfField.x - 2)
          addScore(false);
      else if (ball.pos.x > halfField.x + 2)
          addScore(true);
  }

  function gameUpdatePost()
  {
      // keep camera stable
      setCameraPos(vec2(0,0));
  }

  function gameRender()
  {
      // background
      drawRect(cameraPos, vec2(200), rgb(.08,.08,.08));

      // playfield
      drawRect(cameraPos, fieldSize, rgb(.12,.12,.12));

      // center dashed line
      const dashCount = 18;
      for (let i=0; i<dashCount; i++)
      {
          const t = (i/(dashCount-1))*2 - 1;
          const y = t * (halfField.y - 1);
          drawRect(vec2(0, y), vec2(.35, .7), rgb(.85,.85,.85));
      }

      // paddles
      drawRect(left.pos, paddleSize, rgb(.95,.95,.95));
      drawRect(right.pos, paddleSize, rgb(.95,.95,.95));

      // ball
      drawRect(ball.pos, ballSize, rgb(1,1,1));

      // top/bottom border lines (subtle)
      drawRect(vec2(0, halfField.y + .15), vec2(fieldSize.x, .15), rgb(.2,.2,.2));
      drawRect(vec2(0,-halfField.y - .15), vec2(fieldSize.x, .15), rgb(.2,.2,.2));
  }

  function gameRenderPost()
  {
      // score
      const scoreText = `${scoreL}    ${scoreR}`;
      drawTextScreen(scoreText, vec2(mainCanvasSize.x/2, 60), 80, hsl(0,0,1), 6, hsl(0,0,0));

      // hints
      const lines = [];
      lines.push('Left: W/S');
      lines.push(aiRight ? 'Right: AI (press T to toggle)' : 'Right: ↑/↓ (press T for AI)');
      lines.push('Space: Serve / Start (enables sound)');
      lines.push('R: Reset');

      // status message
      if (gameOver)
      {
          const winner = scoreL > scoreR ? 'Left Wins!' : 'Right Wins!';
          lines.unshift(winner);
          lines.unshift('');
          lines.unshift('Game Over');
      }
      else if (waitingForServe)
      {
          lines.unshift('');
          lines.unshift('Press Space to Serve');
      }

      const x = mainCanvasSize.x/2;
      let y = mainCanvasSize.y - 120;
      for (const s of lines)
      {
          drawTextScreen(s, vec2(x, y), 26, hsl(0,0,1), 4, hsl(0,0,0));
          y += 28;
      }
  }

  // Startup LittleJS Engine
  engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);
  </script>
</body>
</html>
