<!DOCTYPE html><head>
<title>LittleJS AI Starter Project</title>
<meta charset="utf-8">
</head><body style="background:#000">
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/littlejs.js"></script>
<script src="https://cdn.jsdelivr.net/npm/littlejsengine@1.17.15/dist/box2d.wasm.js"></script>
<script>
'use strict';

// engine settings, do not remove
debugWatermark = false; // Hide debug watermark in corner
showEngineVersion = false; // Hide engine version console display
paused = false; // Start unpaused

// engine settings, customize if necessary
gravity = vec2(0, 0); // No gravity by default
cameraPos = vec2(0, 0); // Camera centered at origin
cameraScale = 32; // Camera zoom, larger is more zoomed in

// AI can use this class to make sound effects
class SoundGenerator extends Sound 
{
    constructor(params = {})
    {
        const {
            volume = 1,        // Volume scale (percent)
            randomness = .05,  // How much to randomize frequency (percent Hz)
            frequency = 220,   // Frequency of sound (Hz)
            attack = 0,        // Attack time, how fast sound starts (seconds)
            release = .1,      // Release time, how fast sound fades out (seconds)
            shapeCurve = 1,    // Squarenes of wave (0=square, 1=normal, 2=pointy)
            slide = 0,         // How much to slide frequency (kHz/s)
            pitchJump = 0,     // Frequency of pitch jump (Hz)
            pitchJumpTime = 0, // Time of pitch jump (seconds)
            repeatTime = 0,    // Resets some parameters periodically (seconds)
            noise = 0,         // How much random noise to add (percent)
            bitCrush = 0,      // Resamples at a lower frequency in (samples*100)
            delay = 0,         // Overlap sound with itself for reverb and flanger effects (seconds)
        } = params;
        
        super([volume, randomness, frequency, attack, 0, release, 0, shapeCurve, slide, 0, pitchJump, pitchJumpTime, repeatTime, noise, 0, bitCrush, delay, 1, 0, 0, 0]);
    }
}

///////////////////////////////////////////////////////////////////////////////
// mini golf (box2d)

// course constants
const COURSE_SIZE = vec2(34, 18);
const WALL_THICKNESS = 1;
const BALL_DIAMETER = 1.0;
const HOLE_DIAMETER = 1.6;
const HOLE_RING_DIAMETER = 2.2;
const MAX_DRAG = 10;        // world units
const SHOT_STRENGTH = 22;   // impulse scale
const STOP_SPEED = .2;

// game state
let courseObjects = [];
let ball, hole;
let holeIndex = 0;
let holeStrokes = 0;
let totalStrokes = 0;
let completeTimer = new Timer();

// aiming
let aiming = false;
let aimMouseStart = vec2();
let aimDrag = vec2();

// sounds
let sfxHit, sfxSink;

// holes (simple hand-built layouts)
const holes = [
    {
        tee:  vec2(-14, -7),
        hole: vec2( 14,  7),
        obstacles: [
            {type:'box', pos:vec2(-2,  0), size:vec2(1.2, 10), angle: 0.2},
            {type:'box', pos:vec2( 6, -3), size:vec2(8,   1.2), angle:-0.25},
            {type:'circle', pos:vec2(-8,  5), diameter:3.0},
        ],
    },
    {
        tee:  vec2(-15,  6),
        hole: vec2( 15, -6),
        obstacles: [
            {type:'box', pos:vec2(-4,  0), size:vec2(10,  1.2), angle: 0.35},
            {type:'box', pos:vec2( 4,  0), size:vec2(10,  1.2), angle:-0.35},
            {type:'box', pos:vec2( 0, -6), size:vec2(1.2,  5.5), angle:0},
            {type:'circle', pos:vec2( 0,  6), diameter:2.6},
        ],
    },
    {
        tee:  vec2(-14,  0),
        hole: vec2( 14,  0),
        obstacles: [
            {type:'box', pos:vec2( 0,  5), size:vec2(24, 1.2), angle:0},
            {type:'box', pos:vec2( 0, -5), size:vec2(24, 1.2), angle:0},
            {type:'circle', pos:vec2(-4, 0), diameter:3.0},
            {type:'circle', pos:vec2( 4, 0), diameter:3.0},
        ],
    },
];

///////////////////////////////////////////////////////////////////////////////
// helpers

function addCourseObject(o)
{
    courseObjects.push(o);
    return o;
}

function clearCourse()
{
    aiming = false;
    aimDrag = vec2();

    if (ball) ball.destroy();
    if (hole) hole.destroy();

    for (const o of courseObjects)
        o.destroy();
    courseObjects.length = 0;
}

function createWall(pos, size, angle=0)
{
    const w = addCourseObject(new Box2dStaticObject(pos));
    w.color = rgb(.2,.25,.2);
    w.outlineColor = rgb(0,0,0,.5);
    w.lineWidth = .08;
    // addBox(size, offset=vec2(), angle=0, density=0, friction=.2, restitution=0, isSensor=false)
    // higher restitution so the ball bounces more off walls
    w.addBox(size, vec2(), angle, 0, .25, .9);
    return w;
}

function createBumper(pos, size, angle=0)
{
    const b = addCourseObject(new Box2dStaticObject(pos));
    b.color = rgb(.5,.4,.2);
    b.outlineColor = rgb(0,0,0,.6);
    b.lineWidth = .08;
    b.addBox(size, vec2(), angle, 0, .3, .6);
    return b;
}

function createPillar(pos, diameter)
{
    const p = addCourseObject(new Box2dStaticObject(pos));
    p.color = rgb(.45,.45,.5);
    p.outlineColor = rgb(0,0,0,.6);
    p.lineWidth = .08;
    p.addCircle(diameter, vec2(), 0, .3, .4);
    return p;
}

class GolfBall extends Box2dObject
{
    constructor(pos)
    {
        super(pos);
        this.color = WHITE;
        this.outlineColor = rgb(0,0,0,.7);
        this.lineWidth = .06;

        this.addCircle(BALL_DIAMETER, vec2(), 1, .25, .1);
        // almost no damping so the ball keeps rolling
        this.setLinearDamping(.22);
        this.setAngularDamping(.14);
        this.setBullet(true);
    }
}

class Hole extends Box2dStaticObject
{
    constructor(pos)
    {
        super(pos);
        this.pos = pos.copy();
        this.color = BLACK;
        this.outlineColor = BLACK;
        this.lineWidth = 0;

        // sensor so we can detect contacts
        this.addCircle(HOLE_DIAMETER, vec2(), 0, 0, 0, true);
    }

    beginContact(other)
    {
        // only sink the golf ball, and only once
        if (other !== ball || completeTimer.isSet())
            return;

        // require it to be slow-ish to "count" as sunk
        if (ball.getSpeed() > 8)
            return;

        // start completion
        completeTimer.set(1.0);

        // a little suction + heavy damping
        ball.setLinearDamping(8);
        ball.setAngularDamping(8);
        ball.setLinearVelocity(ball.getLinearVelocity().scale(.25));
        ball.applyAcceleration(this.pos.subtract(ball.pos).scale(4), ball.getCenterOfMass());

        sfxSink.play();
    }

    render()
    {
        // draw hole ring and center
        drawCircle(this.pos, HOLE_RING_DIAMETER, rgb(0,0,0,.35));
        drawCircle(this.pos, HOLE_DIAMETER, rgb(0,0,0,.9));

        // simple flag
        const poleTop = this.pos.add(vec2(0, 3.2));
        drawLine(this.pos.add(vec2(0, .8)), poleTop, .12, rgb(.9,.9,.9));
        drawPoly([
            poleTop,
            poleTop.add(vec2(2.1, -.6)),
            poleTop.add(vec2(0, -1.2)),
        ], rgb(1,.2,.2));
    }
}

function buildHole(index)
{
    clearCourse();

    holeIndex = mod(index, holes.length);
    holeStrokes = 0;
    completeTimer.unset();

    const h = holes[holeIndex];

    // boundaries
    const half = COURSE_SIZE.scale(.5);
    createWall(vec2(0,  half.y + WALL_THICKNESS/2), vec2(COURSE_SIZE.x + 2*WALL_THICKNESS, WALL_THICKNESS)); // top
    createWall(vec2(0, -half.y - WALL_THICKNESS/2), vec2(COURSE_SIZE.x + 2*WALL_THICKNESS, WALL_THICKNESS)); // bottom
    createWall(vec2( half.x + WALL_THICKNESS/2, 0), vec2(WALL_THICKNESS, COURSE_SIZE.y)); // right
    createWall(vec2(-half.x - WALL_THICKNESS/2, 0), vec2(WALL_THICKNESS, COURSE_SIZE.y)); // left

    // obstacles
    for (const o of h.obstacles)
    {
        if (o.type === 'box')
            createBumper(o.pos, o.size, o.angle || 0);
        else if (o.type === 'circle')
            createPillar(o.pos, o.diameter);
    }

    // hole + ball
    hole = new Hole(h.hole);
    ball = new GolfBall(h.tee);

    // tiny tee marker
    const tee = addCourseObject(new EngineObject(h.tee, vec2(.8,.8)));
    tee.color = rgb(1,1,1,.2);
    tee.renderOrder = -1;
    tee.update = ()=>{};
}

function canShoot()
{
    return ball && !completeTimer.isSet() && ball.getSpeed() < STOP_SPEED;
}

///////////////////////////////////////////////////////////////////////////////
async function gameInit()
{
    // setup box2d first!
    await box2dInit();

    // visuals
    canvasClearColor = rgb(.08,.12,.08);
    setCanvasFixedSize(vec2(1280, 720));
    cameraPos = vec2();
    cameraScale = 32;

    // sounds
    sfxHit = new SoundGenerator({
        volume:.9,
        frequency:260,
        attack:0,
        release:.12,
        shapeCurve:1.4,
        slide:-2.2,
        noise:.02,
    });

    sfxSink = new SoundGenerator({
        volume:.8,
        frequency:620,
        attack:0,
        release:.18,
        shapeCurve:1.1,
        slide:-3.5,
        pitchJump:120,
        pitchJumpTime:.06,
        delay:.05,
    });

    // build first hole
    buildHole(0);
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdate()
{
    // reset/retry
    if (keyWasPressed('KeyR'))
        buildHole(holeIndex);

    // next hole (debug)
    if (keyWasPressed('KeyN'))
        buildHole(holeIndex + 1);

    // completion
    if (completeTimer.elapsed())
        buildHole(holeIndex + 1);

    // aiming controls
    if (completeTimer.isSet())
    {
        aiming = false;
        return;
    }

    if (aiming)
    {
        if (mouseIsDown(0))
        {
            // aim in the direction you drag the mouse
            aimDrag = mousePos.subtract(ball.pos);
        }
        else
            aiming = false;

        if (mouseWasReleased(0))
        {
            const drag = mousePos.subtract(ball.pos);
            const dragLen = drag.length();
            const power = clamp(dragLen / MAX_DRAG);

            aiming = false;
            aimDrag = vec2();

            if (!canShoot() || power < .05)
                return;

            const dir = drag.normalize();
            const impulse = dir.scale(power * SHOT_STRENGTH);

            ball.applyAcceleration(impulse, ball.getCenterOfMass());
            sfxHit.play();

            holeStrokes++;
            totalStrokes++;
        }
    }
    else
    {
        // start aiming only if clicking near ball and ball is stopped
        if (mouseWasPressed(0) && canShoot())
        {
            if (mousePos.distance(ball.pos) < 2.4)
            {
                aiming = true;
                aimMouseStart = mousePos.copy();
                aimDrag = vec2();
            }
        }
    }

    // gentle clamp: if ball escaped somehow, respawn at tee
    const half = COURSE_SIZE.scale(.5).add(vec2(6));
    if (ball.pos.x < -half.x || ball.pos.x > half.x || ball.pos.y < -half.y || ball.pos.y > half.y)
        buildHole(holeIndex);
}

///////////////////////////////////////////////////////////////////////////////
function gameUpdatePost()
{
    // center camera
    setCameraPos(vec2());
    
    // Rapid slowdown when ball is moving slowly but not yet stopped
    if (ball && !completeTimer.isSet())
    {
        const speed = ball.getSpeed();
        const slowdownThreshold = STOP_SPEED * 10;  // 2.0 - starts slowing down earlier
        if (speed > STOP_SPEED && speed < slowdownThreshold)
        {
            // Apply extra damping to rapidly slow down the ball
            const vel = ball.getLinearVelocity();
            ball.setLinearVelocity(vel.scale(0.92));  // reduce velocity each frame
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
function gameRender()
{
    // background grass
    drawRect(cameraPos, COURSE_SIZE.add(vec2(6)), rgb(.12,.22,.12));
    drawRect(cameraPos, COURSE_SIZE.add(vec2(1.2)), rgb(.18,.35,.18));
    drawRect(cameraPos, COURSE_SIZE, rgb(.14,.28,.14));

    // subtle stripes
    for (let i=-8; i<=8; i++)
        drawRect(vec2(i*2, 0), vec2(.7, COURSE_SIZE.y), rgb(1,1,1,.03));

    // tee -> hole hint line (only when stopped)
    if (canShoot())
        drawLine(ball.pos, hole.pos, .08, rgb(1,1,1,.12));
}

///////////////////////////////////////////////////////////////////////////////
function gameRenderPost()
{
    // aim UI
    if (aiming && canShoot())
    {
        const drag = mousePos.subtract(ball.pos);
        const dragLen = drag.length();
        const power = clamp(dragLen / MAX_DRAG);

        const dir = dragLen ? drag.scale(1/dragLen) : vec2(1,0);
        const tip = ball.pos.add(dir.scale(6*power));
        const headLen = 1.1;
        const headWid = .7;
        const base = tip.subtract(dir.scale(headLen));
        const perp = vec2(-dir.y, dir.x);

        // shaft stops at the base of the triangle head (avoids a "Y" look)
        drawLine(ball.pos, base, .18, rgb(1,1,1,.7));

        // pointed triangle arrow head
        const p1 = base.add(perp.scale(headWid*.5));
        const p2 = base.subtract(perp.scale(headWid*.5));
        drawPoly([tip, p1, p2], rgb(1,1,1,.7));

        // power text
        drawTextScreen(`Power ${(power*100|0)}%`, vec2(mainCanvasSize.x/2, mainCanvasSize.y-36), 36, WHITE, 4, BLACK);
    }

    // completion text
    if (completeTimer.isSet())
    {
        drawTextScreen('SUNK!', vec2(mainCanvasSize.x/2, mainCanvasSize.y/2), 120, rgb(1,1,1,.95), 8, rgb(0,0,0,.7));
    }

    // hud
    const hud = `Hole ${holeIndex+1}/${holes.length}   Strokes: ${holeStrokes}   Total: ${totalStrokes}\n` +
        `Drag from the ball to aim + shoot.  R = Retry, N = Next hole`;
    drawTextScreen(hud, vec2(mainCanvasSize.x/2, 52), 36, WHITE, 4, rgb(0,0,0,.6));
}

///////////////////////////////////////////////////////////////////////////////
// Startup LittleJS Engine
engineInit(gameInit, gameUpdate, gameUpdatePost, gameRender, gameRenderPost);

</script>
